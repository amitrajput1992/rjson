import { RecordNode, r, rtp, RT } from "../../../r";
import { ElementType } from "../../../r/definitions/elements";
import { RuleEvent } from "../../../r/definitions/rules";
import { VarCategory } from "../../../r/definitions/variables/VariableSubTypes";
import { IOrder } from "../../IOrder";

/**
 * For media upload element, there is a predefined variable which gets populated when a viewer uploads media.
 * Since there is only one such predefined var, this restricts it to only one upload per view.
 * 
 * Changed flow:
 * - delink the predefined variable from the media upload element for older projects and add separate var for each
 * - create a new variable at run-time for any future media upload elements
 */

class Migration implements IOrder {
  execute(projectJson: unknown) {
    const pJson = projectJson as RecordNode<RT.project>;
    const projectF = r.record(pJson);
    const mediaUploadVar = projectF.getRecord(RT.variable, -4); // -4 is the id for predefined var media_upload_uri

    if (mediaUploadVar !== undefined) {
      // change record id from -4 to 3000, set var_category=autogenerated
      projectF.changeRecordId(RT.variable, -4, 3000);
      r.record(mediaUploadVar).set(rtp.variable.var_category, VarCategory.autogenerated);

      // for each media upload element, set its media_upload_var_id as 3000
      projectF.getAllDeepChildren(RT.element).forEach(e => {
        if (e.props.element_type === ElementType.media_upload) {
          r.record(e).set(rtp.element.media_upload_var_id, 3000);
        }
      });

      // delete all *autogenerated* media upload rules for when "submit" is clicked
      // these do not show up on the UI
      const rulesIdsToDelete = projectF.getAllDeepChildrenIdsWithFilter(RT.rule, (ruleJson) => {
        if (ruleJson.props.events_and === undefined && ruleJson.props.accent_color === undefined) {
          const whenEvent = r.record(ruleJson).getRecords(RT.when_event)[0];
          if (whenEvent.props.event === RuleEvent.on_successful_upload && whenEvent.props.co_type === ElementType.media_upload) {
            const thenActions = r.record(ruleJson).getRecords(RT.then_action);
            for (const ta of thenActions) {
              if (ta.props.co_id && ta.props.co_id === -4) {
                return true;
              }
            }
          }
        }
        return false;
      });
      for(const ruleId of rulesIdsToDelete) {
        projectF.deleteDeepRecord(RT.rule, ruleId);
      }

      // update when_events and then_actions which might be using this variable
      projectF.getAllDeepChildren(RT.then_action).forEach(ta => {
        if (ta.props.co_id && ta.props.co_id === -4) {
          r.record(ta).set(rtp.then_action.co_id, 3000);
        }
      });
      projectF.getAllDeepChildren(RT.when_event).forEach(we => {
        if (we.props.co_id && we.props.co_id === -4) {
          r.record(we).set(rtp.when_event.co_id, 3000);
        }
      });
    }
    projectF.set(rtp.project.version, 116);
  }
}

const migration = new Migration();
export default migration;